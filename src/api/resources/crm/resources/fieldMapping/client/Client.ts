// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient";
import { normalizeClientOptions } from "../../../../../../BaseClient";
import * as core from "../../../../../../core";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers";
import * as environments from "../../../../../../environments";
import * as errors from "../../../../../../errors/index";
import * as serializers from "../../../../../../serialization/index";
import type * as Merge from "../../../../../index";

export declare namespace FieldMappingClient {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class FieldMappingClient {
    protected readonly _options: FieldMappingClient.Options;

    constructor(options: FieldMappingClient.Options) {
        this._options = normalizeClientOptions(options);
    }

    /**
     * Get all Field Mappings for this Linked Account. Field Mappings are mappings between third-party Remote Fields and user defined Merge fields. [Learn more](https://docs.merge.dev/supplemental-data/field-mappings/overview/).
     *
     * @param {Merge.crm.FieldMappingsRetrieveRequest} request
     * @param {FieldMappingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.crm.fieldMapping.fieldMappingsRetrieve({
     *         excludeRemoteFieldMetadata: true
     *     })
     */
    public fieldMappingsRetrieve(
        request: Merge.crm.FieldMappingsRetrieveRequest = {},
        requestOptions?: FieldMappingClient.RequestOptions,
    ): core.HttpResponsePromise<Merge.crm.FieldMappingApiInstanceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fieldMappingsRetrieve(request, requestOptions));
    }

    private async __fieldMappingsRetrieve(
        request: Merge.crm.FieldMappingsRetrieveRequest = {},
        requestOptions?: FieldMappingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.crm.FieldMappingApiInstanceResponse>> {
        const { excludeRemoteFieldMetadata } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (excludeRemoteFieldMetadata != null) {
            _queryParams.exclude_remote_field_metadata = excludeRemoteFieldMetadata.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "X-Account-Token": requestOptions?.accountToken ?? this._options?.accountToken,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                "crm/v1/field-mappings",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.crm.FieldMappingApiInstanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MergeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MergeTimeoutError("Timeout exceeded when calling GET /crm/v1/field-mappings.");
            case "unknown":
                throw new errors.MergeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create new Field Mappings that will be available after the next scheduled sync. This will cause the next sync for this Linked Account to sync **ALL** data from start.
     *
     * @param {Merge.crm.CreateFieldMappingRequest} request
     * @param {FieldMappingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.crm.fieldMapping.fieldMappingsCreate({
     *         excludeRemoteFieldMetadata: true,
     *         targetFieldName: "example_target_field_name",
     *         targetFieldDescription: "this is a example description of the target field",
     *         remoteFieldTraversalPath: ["example_remote_field"],
     *         remoteMethod: "GET",
     *         remoteUrlPath: "/example-url-path",
     *         commonModelName: "ExampleCommonModel"
     *     })
     */
    public fieldMappingsCreate(
        request: Merge.crm.CreateFieldMappingRequest,
        requestOptions?: FieldMappingClient.RequestOptions,
    ): core.HttpResponsePromise<Merge.crm.FieldMappingInstanceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fieldMappingsCreate(request, requestOptions));
    }

    private async __fieldMappingsCreate(
        request: Merge.crm.CreateFieldMappingRequest,
        requestOptions?: FieldMappingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.crm.FieldMappingInstanceResponse>> {
        const { excludeRemoteFieldMetadata, ..._body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (excludeRemoteFieldMetadata != null) {
            _queryParams.exclude_remote_field_metadata = excludeRemoteFieldMetadata.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "X-Account-Token": requestOptions?.accountToken ?? this._options?.accountToken,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                "crm/v1/field-mappings",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: serializers.crm.CreateFieldMappingRequest.jsonOrThrow(_body, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.crm.FieldMappingInstanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MergeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MergeTimeoutError("Timeout exceeded when calling POST /crm/v1/field-mappings.");
            case "unknown":
                throw new errors.MergeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes Field Mappings for a Linked Account. All data related to this Field Mapping will be deleted and these changes will be reflected after the next scheduled sync. This will cause the next sync for this Linked Account to sync **ALL** data from start.
     *
     * @param {string} field_mapping_id
     * @param {FieldMappingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.crm.fieldMapping.fieldMappingsDestroy("field_mapping_id")
     */
    public fieldMappingsDestroy(
        field_mapping_id: string,
        requestOptions?: FieldMappingClient.RequestOptions,
    ): core.HttpResponsePromise<Merge.crm.FieldMappingInstanceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fieldMappingsDestroy(field_mapping_id, requestOptions));
    }

    private async __fieldMappingsDestroy(
        field_mapping_id: string,
        requestOptions?: FieldMappingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.crm.FieldMappingInstanceResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "X-Account-Token": requestOptions?.accountToken ?? this._options?.accountToken,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                `crm/v1/field-mappings/${core.url.encodePathParam(field_mapping_id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.crm.FieldMappingInstanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MergeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MergeTimeoutError(
                    "Timeout exceeded when calling DELETE /crm/v1/field-mappings/{field_mapping_id}.",
                );
            case "unknown":
                throw new errors.MergeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create or update existing Field Mappings for a Linked Account. Changes will be reflected after the next scheduled sync. This will cause the next sync for this Linked Account to sync **ALL** data from start.
     *
     * @param {string} field_mapping_id
     * @param {Merge.crm.PatchedEditFieldMappingRequest} request
     * @param {FieldMappingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.crm.fieldMapping.fieldMappingsPartialUpdate("field_mapping_id")
     */
    public fieldMappingsPartialUpdate(
        field_mapping_id: string,
        request: Merge.crm.PatchedEditFieldMappingRequest = {},
        requestOptions?: FieldMappingClient.RequestOptions,
    ): core.HttpResponsePromise<Merge.crm.FieldMappingInstanceResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__fieldMappingsPartialUpdate(field_mapping_id, request, requestOptions),
        );
    }

    private async __fieldMappingsPartialUpdate(
        field_mapping_id: string,
        request: Merge.crm.PatchedEditFieldMappingRequest = {},
        requestOptions?: FieldMappingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.crm.FieldMappingInstanceResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "X-Account-Token": requestOptions?.accountToken ?? this._options?.accountToken,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                `crm/v1/field-mappings/${core.url.encodePathParam(field_mapping_id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.crm.PatchedEditFieldMappingRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.crm.FieldMappingInstanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MergeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MergeTimeoutError(
                    "Timeout exceeded when calling PATCH /crm/v1/field-mappings/{field_mapping_id}.",
                );
            case "unknown":
                throw new errors.MergeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all remote fields for a Linked Account. Remote fields are third-party fields that are accessible after initial sync if remote_data is enabled. You can use remote fields to override existing Merge fields or map a new Merge field. [Learn more](https://docs.merge.dev/supplemental-data/field-mappings/overview/).
     *
     * @param {Merge.crm.RemoteFieldsRetrieveRequest} request
     * @param {FieldMappingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.crm.fieldMapping.remoteFieldsRetrieve({
     *         commonModels: "common_models",
     *         includeExampleValues: "include_example_values"
     *     })
     */
    public remoteFieldsRetrieve(
        request: Merge.crm.RemoteFieldsRetrieveRequest = {},
        requestOptions?: FieldMappingClient.RequestOptions,
    ): core.HttpResponsePromise<Merge.crm.RemoteFieldApiResponse> {
        return core.HttpResponsePromise.fromPromise(this.__remoteFieldsRetrieve(request, requestOptions));
    }

    private async __remoteFieldsRetrieve(
        request: Merge.crm.RemoteFieldsRetrieveRequest = {},
        requestOptions?: FieldMappingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.crm.RemoteFieldApiResponse>> {
        const { commonModels, includeExampleValues } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (commonModels != null) {
            _queryParams.common_models = commonModels;
        }

        if (includeExampleValues != null) {
            _queryParams.include_example_values = includeExampleValues;
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "X-Account-Token": requestOptions?.accountToken ?? this._options?.accountToken,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                "crm/v1/remote-fields",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.crm.RemoteFieldApiResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MergeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MergeTimeoutError("Timeout exceeded when calling GET /crm/v1/remote-fields.");
            case "unknown":
                throw new errors.MergeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all organization-wide Target Fields, this will not include any Linked Account specific Target Fields. Organization-wide Target Fields are additional fields appended to the Merge Common Model for all Linked Accounts in a category. [Learn more](https://docs.merge.dev/supplemental-data/field-mappings/target-fields/).
     *
     * @param {FieldMappingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.crm.fieldMapping.targetFieldsRetrieve()
     */
    public targetFieldsRetrieve(
        requestOptions?: FieldMappingClient.RequestOptions,
    ): core.HttpResponsePromise<Merge.crm.ExternalTargetFieldApiResponse> {
        return core.HttpResponsePromise.fromPromise(this.__targetFieldsRetrieve(requestOptions));
    }

    private async __targetFieldsRetrieve(
        requestOptions?: FieldMappingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.crm.ExternalTargetFieldApiResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                "X-Account-Token": requestOptions?.accountToken ?? this._options?.accountToken,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                "crm/v1/target-fields",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.crm.ExternalTargetFieldApiResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MergeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MergeTimeoutError("Timeout exceeded when calling GET /crm/v1/target-fields.");
            case "unknown":
                throw new errors.MergeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.apiKey)}`;
    }
}
