// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient";
import * as core from "../../../../../../core";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers";
import * as environments from "../../../../../../environments";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError";
import * as errors from "../../../../../../errors/index";
import * as serializers from "../../../../../../serialization/index";
import type * as Merge from "../../../../../index";

export declare namespace FieldMappingClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class FieldMappingClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<FieldMappingClient.Options>;

    constructor(options: FieldMappingClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Get all Field Mappings for this Linked Account. Field Mappings are mappings between third-party Remote Fields and user defined Merge fields. [Learn more](https://docs.merge.dev/supplemental-data/field-mappings/overview/).
     *
     * @param {Merge.chat.FieldMappingsRetrieveRequest} request
     * @param {FieldMappingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.chat.fieldMapping.fieldMappingsRetrieve({
     *         excludeRemoteFieldMetadata: true
     *     })
     */
    public fieldMappingsRetrieve(
        request: Merge.chat.FieldMappingsRetrieveRequest = {},
        requestOptions?: FieldMappingClient.RequestOptions,
    ): core.HttpResponsePromise<Merge.chat.FieldMappingApiInstanceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fieldMappingsRetrieve(request, requestOptions));
    }

    private async __fieldMappingsRetrieve(
        request: Merge.chat.FieldMappingsRetrieveRequest = {},
        requestOptions?: FieldMappingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.chat.FieldMappingApiInstanceResponse>> {
        const { excludeRemoteFieldMetadata } = request;
        const _queryParams: Record<string, unknown> = {
            exclude_remote_field_metadata: excludeRemoteFieldMetadata,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "X-Account-Token": requestOptions?.accountToken ?? this._options?.accountToken }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                "chat/v1/field-mappings",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.chat.FieldMappingApiInstanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/chat/v1/field-mappings");
    }

    /**
     * Create new Field Mappings that will be available after the next scheduled sync. This will cause the next sync for this Linked Account to sync **ALL** data from start.
     *
     * @param {Merge.chat.CreateFieldMappingRequest} request
     * @param {FieldMappingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.chat.fieldMapping.fieldMappingsCreate({
     *         excludeRemoteFieldMetadata: true,
     *         targetFieldName: "example_target_field_name",
     *         targetFieldDescription: "this is a example description of the target field",
     *         remoteFieldTraversalPath: ["example_remote_field"],
     *         remoteMethod: "GET",
     *         remoteUrlPath: "/example-url-path",
     *         commonModelName: "ExampleCommonModel"
     *     })
     */
    public fieldMappingsCreate(
        request: Merge.chat.CreateFieldMappingRequest,
        requestOptions?: FieldMappingClient.RequestOptions,
    ): core.HttpResponsePromise<Merge.chat.FieldMappingInstanceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fieldMappingsCreate(request, requestOptions));
    }

    private async __fieldMappingsCreate(
        request: Merge.chat.CreateFieldMappingRequest,
        requestOptions?: FieldMappingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.chat.FieldMappingInstanceResponse>> {
        const { excludeRemoteFieldMetadata, ..._body } = request;
        const _queryParams: Record<string, unknown> = {
            exclude_remote_field_metadata: excludeRemoteFieldMetadata,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "X-Account-Token": requestOptions?.accountToken ?? this._options?.accountToken }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                "chat/v1/field-mappings",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: serializers.chat.CreateFieldMappingRequest.jsonOrThrow(_body, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.chat.FieldMappingInstanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/chat/v1/field-mappings");
    }

    /**
     * Deletes Field Mappings for a Linked Account. All data related to this Field Mapping will be deleted and these changes will be reflected after the next scheduled sync. This will cause the next sync for this Linked Account to sync **ALL** data from start.
     *
     * @param {string} field_mapping_id
     * @param {FieldMappingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.chat.fieldMapping.fieldMappingsDestroy("field_mapping_id")
     */
    public fieldMappingsDestroy(
        field_mapping_id: string,
        requestOptions?: FieldMappingClient.RequestOptions,
    ): core.HttpResponsePromise<Merge.chat.FieldMappingInstanceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fieldMappingsDestroy(field_mapping_id, requestOptions));
    }

    private async __fieldMappingsDestroy(
        field_mapping_id: string,
        requestOptions?: FieldMappingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.chat.FieldMappingInstanceResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "X-Account-Token": requestOptions?.accountToken ?? this._options?.accountToken }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                `chat/v1/field-mappings/${core.url.encodePathParam(field_mapping_id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.chat.FieldMappingInstanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/chat/v1/field-mappings/{field_mapping_id}",
        );
    }

    /**
     * Create or update existing Field Mappings for a Linked Account. Changes will be reflected after the next scheduled sync. This will cause the next sync for this Linked Account to sync **ALL** data from start.
     *
     * @param {string} field_mapping_id
     * @param {Merge.chat.PatchedEditFieldMappingRequest} request
     * @param {FieldMappingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.chat.fieldMapping.fieldMappingsPartialUpdate("field_mapping_id")
     */
    public fieldMappingsPartialUpdate(
        field_mapping_id: string,
        request: Merge.chat.PatchedEditFieldMappingRequest = {},
        requestOptions?: FieldMappingClient.RequestOptions,
    ): core.HttpResponsePromise<Merge.chat.FieldMappingInstanceResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__fieldMappingsPartialUpdate(field_mapping_id, request, requestOptions),
        );
    }

    private async __fieldMappingsPartialUpdate(
        field_mapping_id: string,
        request: Merge.chat.PatchedEditFieldMappingRequest = {},
        requestOptions?: FieldMappingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.chat.FieldMappingInstanceResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "X-Account-Token": requestOptions?.accountToken ?? this._options?.accountToken }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                `chat/v1/field-mappings/${core.url.encodePathParam(field_mapping_id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.chat.PatchedEditFieldMappingRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.chat.FieldMappingInstanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "PATCH",
            "/chat/v1/field-mappings/{field_mapping_id}",
        );
    }

    /**
     * Get all remote fields for a Linked Account. Remote fields are third-party fields that are accessible after initial sync if remote_data is enabled. You can use remote fields to override existing Merge fields or map a new Merge field. [Learn more](https://docs.merge.dev/supplemental-data/field-mappings/overview/).
     *
     * @param {Merge.chat.RemoteFieldsRetrieveRequest} request
     * @param {FieldMappingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.chat.fieldMapping.remoteFieldsRetrieve({
     *         commonModels: "common_models",
     *         includeExampleValues: "include_example_values"
     *     })
     */
    public remoteFieldsRetrieve(
        request: Merge.chat.RemoteFieldsRetrieveRequest = {},
        requestOptions?: FieldMappingClient.RequestOptions,
    ): core.HttpResponsePromise<Merge.chat.RemoteFieldApiResponse> {
        return core.HttpResponsePromise.fromPromise(this.__remoteFieldsRetrieve(request, requestOptions));
    }

    private async __remoteFieldsRetrieve(
        request: Merge.chat.RemoteFieldsRetrieveRequest = {},
        requestOptions?: FieldMappingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.chat.RemoteFieldApiResponse>> {
        const { commonModels, includeExampleValues } = request;
        const _queryParams: Record<string, unknown> = {
            common_models: commonModels,
            include_example_values: includeExampleValues,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "X-Account-Token": requestOptions?.accountToken ?? this._options?.accountToken }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                "chat/v1/remote-fields",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.chat.RemoteFieldApiResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/chat/v1/remote-fields");
    }

    /**
     * Get all organization-wide Target Fields, this will not include any Linked Account specific Target Fields. Organization-wide Target Fields are additional fields appended to the Merge Common Model for all Linked Accounts in a category. [Learn more](https://docs.merge.dev/supplemental-data/field-mappings/target-fields/).
     *
     * @param {FieldMappingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.chat.fieldMapping.targetFieldsRetrieve()
     */
    public targetFieldsRetrieve(
        requestOptions?: FieldMappingClient.RequestOptions,
    ): core.HttpResponsePromise<Merge.chat.ExternalTargetFieldApiResponse> {
        return core.HttpResponsePromise.fromPromise(this.__targetFieldsRetrieve(requestOptions));
    }

    private async __targetFieldsRetrieve(
        requestOptions?: FieldMappingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.chat.ExternalTargetFieldApiResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "X-Account-Token": requestOptions?.accountToken ?? this._options?.accountToken }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                "chat/v1/target-fields",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.chat.ExternalTargetFieldApiResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/chat/v1/target-fields");
    }
}
