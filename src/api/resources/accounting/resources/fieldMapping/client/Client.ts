/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../../../environments";
import * as core from "../../../../../../core";
import * as Merge from "../../../../../index";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers";
import * as serializers from "../../../../../../serialization/index";
import * as errors from "../../../../../../errors/index";

export declare namespace FieldMapping {
    export interface Options {
        environment?: core.Supplier<environments.MergeEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey: core.Supplier<core.BearerToken>;
        /** Override the X-Account-Token header */
        accountToken?: core.Supplier<string | undefined>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the X-Account-Token header */
        accountToken?: string | undefined;
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class FieldMapping {
    protected readonly _options: FieldMapping.Options;

    constructor(_options: FieldMapping.Options) {
        this._options = _options;
    }

    /**
     * Get all Field Mappings for this Linked Account. Field Mappings are mappings between third-party Remote Fields and user defined Merge fields. [Learn more](https://docs.merge.dev/supplemental-data/field-mappings/overview/).
     *
     * @param {Merge.accounting.FieldMappingsRetrieveRequest} request
     * @param {FieldMapping.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.accounting.fieldMapping.fieldMappingsRetrieve()
     */
    public fieldMappingsRetrieve(
        request: Merge.accounting.FieldMappingsRetrieveRequest = {},
        requestOptions?: FieldMapping.RequestOptions,
    ): core.HttpResponsePromise<Merge.accounting.FieldMappingApiInstanceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fieldMappingsRetrieve(request, requestOptions));
    }

    private async __fieldMappingsRetrieve(
        request: Merge.accounting.FieldMappingsRetrieveRequest = {},
        requestOptions?: FieldMapping.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.accounting.FieldMappingApiInstanceResponse>> {
        const { excludeRemoteFieldMetadata } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (excludeRemoteFieldMetadata != null) {
            _queryParams["exclude_remote_field_metadata"] = excludeRemoteFieldMetadata.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                "accounting/v1/field-mappings",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Account-Token": requestOptions?.accountToken,
                }),
                requestOptions?.headers,
            ),
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.accounting.FieldMappingApiInstanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MergeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MergeTimeoutError("Timeout exceeded when calling GET /accounting/v1/field-mappings.");
            case "unknown":
                throw new errors.MergeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create new Field Mappings that will be available after the next scheduled sync. This will cause the next sync for this Linked Account to sync **ALL** data from start.
     *
     * @param {Merge.accounting.CreateFieldMappingRequest} request
     * @param {FieldMapping.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.accounting.fieldMapping.fieldMappingsCreate({
     *         targetFieldName: "example_target_field_name",
     *         targetFieldDescription: "this is a example description of the target field",
     *         remoteFieldTraversalPath: ["example_remote_field"],
     *         remoteMethod: "GET",
     *         remoteUrlPath: "/example-url-path",
     *         commonModelName: "ExampleCommonModel"
     *     })
     */
    public fieldMappingsCreate(
        request: Merge.accounting.CreateFieldMappingRequest,
        requestOptions?: FieldMapping.RequestOptions,
    ): core.HttpResponsePromise<Merge.accounting.FieldMappingInstanceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fieldMappingsCreate(request, requestOptions));
    }

    private async __fieldMappingsCreate(
        request: Merge.accounting.CreateFieldMappingRequest,
        requestOptions?: FieldMapping.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.accounting.FieldMappingInstanceResponse>> {
        const { excludeRemoteFieldMetadata, ..._body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (excludeRemoteFieldMetadata != null) {
            _queryParams["exclude_remote_field_metadata"] = excludeRemoteFieldMetadata.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                "accounting/v1/field-mappings",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Account-Token": requestOptions?.accountToken,
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: serializers.accounting.CreateFieldMappingRequest.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.accounting.FieldMappingInstanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MergeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MergeTimeoutError("Timeout exceeded when calling POST /accounting/v1/field-mappings.");
            case "unknown":
                throw new errors.MergeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes Field Mappings for a Linked Account. All data related to this Field Mapping will be deleted and these changes will be reflected after the next scheduled sync. This will cause the next sync for this Linked Account to sync **ALL** data from start.
     *
     * @param {string} fieldMappingId
     * @param {FieldMapping.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.accounting.fieldMapping.fieldMappingsDestroy("field_mapping_id")
     */
    public fieldMappingsDestroy(
        fieldMappingId: string,
        requestOptions?: FieldMapping.RequestOptions,
    ): core.HttpResponsePromise<Merge.accounting.FieldMappingInstanceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__fieldMappingsDestroy(fieldMappingId, requestOptions));
    }

    private async __fieldMappingsDestroy(
        fieldMappingId: string,
        requestOptions?: FieldMapping.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.accounting.FieldMappingInstanceResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                `accounting/v1/field-mappings/${encodeURIComponent(fieldMappingId)}`,
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Account-Token": requestOptions?.accountToken,
                }),
                requestOptions?.headers,
            ),
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.accounting.FieldMappingInstanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MergeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MergeTimeoutError(
                    "Timeout exceeded when calling DELETE /accounting/v1/field-mappings/{field_mapping_id}.",
                );
            case "unknown":
                throw new errors.MergeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create or update existing Field Mappings for a Linked Account. Changes will be reflected after the next scheduled sync. This will cause the next sync for this Linked Account to sync **ALL** data from start.
     *
     * @param {string} fieldMappingId
     * @param {Merge.accounting.PatchedEditFieldMappingRequest} request
     * @param {FieldMapping.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.accounting.fieldMapping.fieldMappingsPartialUpdate("field_mapping_id")
     */
    public fieldMappingsPartialUpdate(
        fieldMappingId: string,
        request: Merge.accounting.PatchedEditFieldMappingRequest = {},
        requestOptions?: FieldMapping.RequestOptions,
    ): core.HttpResponsePromise<Merge.accounting.FieldMappingInstanceResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__fieldMappingsPartialUpdate(fieldMappingId, request, requestOptions),
        );
    }

    private async __fieldMappingsPartialUpdate(
        fieldMappingId: string,
        request: Merge.accounting.PatchedEditFieldMappingRequest = {},
        requestOptions?: FieldMapping.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.accounting.FieldMappingInstanceResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                `accounting/v1/field-mappings/${encodeURIComponent(fieldMappingId)}`,
            ),
            method: "PATCH",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Account-Token": requestOptions?.accountToken,
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.accounting.PatchedEditFieldMappingRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.accounting.FieldMappingInstanceResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MergeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MergeTimeoutError(
                    "Timeout exceeded when calling PATCH /accounting/v1/field-mappings/{field_mapping_id}.",
                );
            case "unknown":
                throw new errors.MergeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all remote fields for a Linked Account. Remote fields are third-party fields that are accessible after initial sync if remote_data is enabled. You can use remote fields to override existing Merge fields or map a new Merge field. [Learn more](https://docs.merge.dev/supplemental-data/field-mappings/overview/).
     *
     * @param {Merge.accounting.RemoteFieldsRetrieveRequest} request
     * @param {FieldMapping.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.accounting.fieldMapping.remoteFieldsRetrieve()
     */
    public remoteFieldsRetrieve(
        request: Merge.accounting.RemoteFieldsRetrieveRequest = {},
        requestOptions?: FieldMapping.RequestOptions,
    ): core.HttpResponsePromise<Merge.accounting.RemoteFieldApiResponse> {
        return core.HttpResponsePromise.fromPromise(this.__remoteFieldsRetrieve(request, requestOptions));
    }

    private async __remoteFieldsRetrieve(
        request: Merge.accounting.RemoteFieldsRetrieveRequest = {},
        requestOptions?: FieldMapping.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.accounting.RemoteFieldApiResponse>> {
        const { commonModels, includeExampleValues } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (commonModels != null) {
            _queryParams["common_models"] = commonModels;
        }

        if (includeExampleValues != null) {
            _queryParams["include_example_values"] = includeExampleValues;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                "accounting/v1/remote-fields",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Account-Token": requestOptions?.accountToken,
                }),
                requestOptions?.headers,
            ),
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.accounting.RemoteFieldApiResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MergeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MergeTimeoutError("Timeout exceeded when calling GET /accounting/v1/remote-fields.");
            case "unknown":
                throw new errors.MergeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all organization-wide Target Fields, this will not include any Linked Account specific Target Fields. Organization-wide Target Fields are additional fields appended to the Merge Common Model for all Linked Accounts in a category. [Learn more](https://docs.merge.dev/supplemental-data/field-mappings/target-fields/).
     *
     * @param {FieldMapping.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.accounting.fieldMapping.targetFieldsRetrieve()
     */
    public targetFieldsRetrieve(
        requestOptions?: FieldMapping.RequestOptions,
    ): core.HttpResponsePromise<Merge.accounting.ExternalTargetFieldApiResponse> {
        return core.HttpResponsePromise.fromPromise(this.__targetFieldsRetrieve(requestOptions));
    }

    private async __targetFieldsRetrieve(
        requestOptions?: FieldMapping.RequestOptions,
    ): Promise<core.WithRawResponse<Merge.accounting.ExternalTargetFieldApiResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MergeEnvironment.Production,
                "accounting/v1/target-fields",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "X-Account-Token": requestOptions?.accountToken,
                }),
                requestOptions?.headers,
            ),
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.accounting.ExternalTargetFieldApiResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.MergeError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MergeError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MergeTimeoutError("Timeout exceeded when calling GET /accounting/v1/target-fields.");
            case "unknown":
                throw new errors.MergeError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.apiKey)}`;
    }
}
